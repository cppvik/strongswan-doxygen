<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>strongSwan: The Versatile IKE Control Interface (VICI) protocol</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="../../strongswan.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">strongSwan
   &#160;<span id="projectnumber">5.3.5</span>
   </div>
   <div id="projectbrief">IPSec implementation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="../../index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="../../pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="../../modules.html"><span>Modules</span></a></li>
      <li><a href="../../namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="../../annotated.html"><span>Classes</span></a></li>
      <li><a href="../../files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="../../search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('dd/d86/md_src_libcharon_plugins_vici_README.html','../../');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">The Versatile IKE Control Interface (VICI) protocol </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The vici plugin implements the server side of an IPC protocol to configure, monitor and control the IKE daemon charon. It uses request/response and event messages to communicate over a reliable stream based transport.</p>
<h2>Transport protocol</h2>
<p>To provide the service, the plugin opens a listening socket using a reliable, stream based transport. charon relies on the different stream service abstractions provided by libstrongswan, such as TCP and UNIX sockets.</p>
<p>A client connects to this service to access functionality. It may send an arbitrary number of packets over the connection before closing it.</p>
<p>To exchange data, the transport protocol is segmented into byte sequences. Each byte sequence is prefixed by a 32-bit length header in network order, followed by the data. The maximum segment length is currently limited to 512KB of data, and the length field contains the length of the data only, not including the length field itself.</p>
<p>The order of byte sequences must be strict, byte sequences must arrive in the same order as sent.</p>
<h2>Packet layer</h2>
<p>Within the byte sequences defined by the transport layer, both the client and the server can exchange packets. The type of packet defines its structure and purpose. The packet type is a 8-bit identifier, and is the first byte in a transport layer byte sequence. The length of the packet is given by the transport layer.</p>
<p>While a packet type may define the format of the wrapped data freely, currently all types either contain a name, a message or both. The following packet types are currently defined:</p>
<ul>
<li><em>CMD_REQUEST = 0</em>: A named request message</li>
<li><em>CMD_RESPONSE = 1</em>: An unnamed response message for a request</li>
<li><em>CMD_UNKNOWN = 2</em>: An unnamed response if requested command is unknown</li>
<li><em>EVENT_REGISTER = 3</em>: A named event registration request</li>
<li><em>EVENT_UNREGISTER = 4</em>: A named event deregistration request</li>
<li><em>EVENT_CONFIRM = 5</em>: An unnamed response for successful event (de-)registration</li>
<li><em>EVENT_UNKNOWN = 6</em>: A unnamed response if event (de-)registration failed</li>
<li><em>EVENT = 7</em>: A named event message</li>
</ul>
<p>For packets having a named type, after the packet type an 8-bit length header of the name follows, indicating the string length in bytes of the name tag, not including the length field itself. The name is an ASCII string that is not null-terminated.</p>
<p>The rest of the packet forms the exchanged message, the length is determined by the transport byte sequence length, subtracting the packet type and the optional name tag in some messages.</p>
<h3>Commands</h3>
<p>Commands are currently always requested by the client. The server replies with a response, or with a CMD_UNKNOWN failure message to let the client know that it does not have a handler for such a command. There is no sequence number to associate responses to requests, so only one command can be active at a time on a single connection.</p>
<h3>Events</h3>
<p>To receive event messages, the client explicitly registers for events by name, and also unregisters if it does not want to receive events of the named kind anymore. The server confirms event registration using EVENT_CONFIRM, or indicates that there is no such event source with EVENT_UNKNOWN.</p>
<p>Events may get raised at any time while registered, even during an active request command. This mechanism is used to feed continuous data during a request, for example.</p>
<h2>Message format</h2>
<p>The defined packet types optionally wrap a message with additional data. Messages are currently used in CMD_REQUEST/CMD_RESPONSE, and in EVENT packets. A message uses a hierarchial tree of sections. Each section (or the implicit root section) contains an arbitrary set of key/value pairs, lists and sub-sections. The length of a message is not part of the message itself, but the wrapping layer, usually calculated from the transport byte sequence length.</p>
<p>The message encoding consists of a sequence of elements. Each element starts with the element type, optionally followed by an element name and/or an element value. Currently the following message element types are defined:</p>
<ul>
<li><em>SECTION_START = 1</em>: Begin a new section having a name</li>
<li><em>SECTION_END = 2</em>: End a previously started section</li>
<li><em>KEY_VALUE = 3</em>: Define a value for a named key in the current section</li>
<li><em>LIST_START = 4</em>: Begin a named list for list items</li>
<li><em>LIST_ITEM = 5</em>: Define an unnamed item value in the current list</li>
<li><em>LIST_END = 6</em>: End a previously started list</li>
</ul>
<p>Types are encoded as 8-bit values. Types having a name (SECTION_START, KEY_VALUE and LIST_START) have an ASCII string following the type, which itself uses an 8-bit length header. The string must not be null-terminated, the string length does not include the length field itself.</p>
<p>Types having a value (KEY_VALUE and LIST_ITEM) have a raw blob sequence, prefixed with a 16-bit network order length. The blob follows the type or the name tag if available, the length defined by the length field does not include the length field itself.</p>
<p>The interpretation of any value is not defined by the message format; it can take arbitrary blobs. The application may specify types for specific keys, such as strings or integer representations. The vici plugin currently uses non-null terminated strings as values only; numbers get encoded as strings.</p>
<h3>Sections</h3>
<p>Sections may be opened in the implicit root section, or any previously section. They can be nested to arbitrary levels. A SECTION_END marker always closes the last opened section; SECTION_START and SECTION_END items must be balanced in a valid message.</p>
<h3>Key/Values</h3>
<p>Key/Value pair elements may appear in the implicit root section or any explicit sub-section at any level. Key names must be unique in the current section, use lists to define multiple values for a key. Key/values may not appear in lists, use a sub-section instead.</p>
<h3>Lists</h3>
<p>Lists may appear at the same locations as Key/Values, and may not be nested. Only a single list may be opened at the same time, and all lists must be closed in valid messages. After opening a list, only list items may appear before the list closing element. Empty lists are allowed, list items may appear within lists only.</p>
<h3>Encoding example</h3>
<p>Consider the following structure using pseudo-markup for this example: </p>
<pre class="fragment">key1 = value1
section1 = {
    sub-section = {
        key2 = value2
    }
    list1 = [ item1, item2 ]
}
</pre><p>The example above reprensents a valid tree structure, that gets encoded as the following C array: </p>
<pre class="fragment">char msg[] = {
    /* key1 = value1 
    3, 4,'k','e','y','1', 0,6,'v','a','l','u','e','1',
    /* section1 
    1, 8,'s','e','c','t','i','o','n','1',
    /* sub-section 
    1, 11,'s','u','b','-','s','e','c','t','i','o','n',
    /* key2 = value2 
    3, 4,'k','e','y','2', 0,6,'v','a','l','u','e','2',
    /* sub-section end 
    2,
    /* list1 
    4, 5, 'l','i','s','t','1',
    /* item1 
    5, 0,5,'i','t','e','m','1',
    /* item2 
    5, 0,5,'i','t','e','m','2',
    /* list1 end 
    6,
    /* section1 end 
    2,
};
</pre><h2>Client-initiated commands</h2>
<p>Based on the packet layer, VICI implements commands requested by the client and responded to by the server using named <em>CMD_REQUEST</em> and <em>CMD_RESPONSE</em> packets wrapping messages. The request message may contain command arguments, the response message the reply.</p>
<p>Some commands use response streaming, that is, a request triggers a series of events to consecutively stream data to the client before the response message completes the stream. A client must register for the appropriate event to receive the stream, and unregister after the response has been received.</p>
<p>The following client issued commands with the appropriate command input and output messages are currently defined:</p>
<h3><a class="el" href="../../de/d09/eap__sim__peer_8c.html#ae000f2bae31d37c237cb739f6d4d4eca">version()</a></h3>
<p>Returns daemon and system specific version information. </p>
<pre class="fragment">{} =&gt; {
    daemon = &lt;IKE daemon name&gt;
    version = &lt;strongSwan version&gt;
    sysname = &lt;operating system name&gt;
    release = &lt;operating system release&gt;
    machine = &lt;hardware identifier&gt;
}
</pre><h3><a class="el" href="../../da/df1/stats_8c.html#afc6a7b29d11eb10f4493e6b43b7f1369">stats()</a></h3>
<p>Returns IKE daemon statistics and load information. </p>
<pre class="fragment">{} =&gt; {
    uptime = {
        running = &lt;relative uptime in human-readable form&gt;
        since = &lt;absolute startup time&gt;
    }
    workers = {
        total = &lt;total number of worker threads&gt;
        idle = &lt;worker threads currently idle&gt;
        active = {
            critical = &lt;threads processing "critical" priority jobs&gt;
            high = &lt;threads processing "high" priority jobs&gt;
            medium = &lt;threads processing "medium" priority jobs&gt;
            low = &lt;threads processing "low" priority jobs&gt;
        }
    }
    queues = {
        critical = &lt;jobs queued with "critical" priority&gt;
        high = &lt;jobs queued with "high" priority&gt;
        medium = &lt;jobs queued with "medium" priority&gt;
        low = &lt;jobs queued with "low" priority&gt;
    }
    scheduled = &lt;number of jobs scheduled for timed execution&gt;
    ikesas = {
        total = &lt;total number of IKE_SAs active&gt;
        half-open = &lt;number of IKE_SAs in half-open state&gt;
    }
    plugins = [
        &lt;names of loaded plugins&gt;
    ]
    mem = { # available if built with leak-detective or on Windows
        total = &lt;total heap memory usage in bytes&gt;
        allocs = &lt;total heap allocation blocks&gt;
        &lt;heap-name&gt;* = { # on Windows only
            total = &lt;heap memory usage in bytes by this heap&gt;
            allocs = &lt;allocated blocks for this heap&gt;
        }
    }
    mallinfo = { # available with mallinfo() support
        sbrk = &lt;non-mmaped space available&gt;
        mmap = &lt;mmaped space available&gt;
        used = &lt;total number of bytes used&gt;
        free = &lt;available but unused bytes&gt;
    }
}
</pre><h3>reload-settings()</h3>
<p>Reloads <em>strongswan.conf</em> settings and all plugins supporting configuration reload. </p>
<pre class="fragment">{} =&gt; {
    success = &lt;yes or no&gt;
    errmsg = &lt;error string on failure&gt;
}
</pre><h3><a class="el" href="../../d7/d9c/cmd__connection_8c.html#a1ef10a08acb2689e03be939316fb0a76">initiate()</a></h3>
<p>Initiates an SA while streaming <em>control-log</em> events. </p>
<pre class="fragment">{
    child = &lt;CHILD_SA configuration name to initiate&gt;
    timeout = &lt;timeout in seconds before returning&gt;
    init-limits = &lt;whether limits may prevent initiating the CHILD_SA&gt;
    loglevel = &lt;loglevel to issue "control-log" events for&gt;
} =&gt; {
    success = &lt;yes or no&gt;
    errmsg = &lt;error string on failure or timeout&gt;
}
</pre><h3><a class="el" href="../../d7/d9c/cmd__connection_8c.html#a7673aa078775c7307b184332c8d97086">terminate()</a></h3>
<p>Terminates an SA while streaming <em>control-log</em> events. </p>
<pre class="fragment">{
    child = &lt;terminate a CHILD_SA by configuration name&gt;
    ike = &lt;terminate an IKE_SA by configuration name&gt;
    child_id = &lt;terminate a CHILD_SA by its reqid&gt;
    ike_id = &lt;terminate an IKE_SA by its unique id&gt;
    timeout = &lt;timeout in seconds before returning&gt;
    loglevel = &lt;loglevel to issue "control-log" events for&gt;
} =&gt; {
    success = &lt;yes or no&gt;
    errmsg = &lt;error string on failure or timeout&gt;
}
</pre><h3><a class="el" href="../../d0/d8e/kernel__wfp__ipsec_8c.html#a7820e93904313d83f7bcae8178e4822a">install()</a></h3>
<p>Install a trap, drop or bypass policy defined by a CHILD_SA config. </p>
<pre class="fragment">{
    child = &lt;CHILD_SA configuration name to install&gt;
} =&gt; {
    success = &lt;yes or no&gt;
    errmsg = &lt;error string on failure&gt;
}
</pre><h3><a class="el" href="../../d0/dbd/install_8c.html#a7bc018d33900e04ae20a13564fbf02db">uninstall()</a></h3>
<p>Uninstall a trap, drop or bypass policy defined by a CHILD_SA config. </p>
<pre class="fragment">{
    child = &lt;CHILD_SA configuration name to install&gt;
} =&gt; {
    success = &lt;yes or no&gt;
    errmsg = &lt;error string on failure&gt;
}
</pre><h3>list-sas()</h3>
<p>Lists currently active IKE_SAs and associated CHILD_SAs by streaming <em>list-sa</em> events. </p>
<pre class="fragment">{
    noblock = &lt;use non-blocking mode if key is set&gt;
    ike = &lt;filter listed IKE_SAs by its name&gt;
    ike_id = &lt;filter listed IKE_SA by its unique id&gt;
} =&gt; {
    # completes after streaming list-sa events
}
</pre><h3>list-policies()</h3>
<p>List currently installed trap, drop and bypass policies by streaming <em>list-policy</em> events. </p>
<pre class="fragment">{
    drop = &lt;set to yes to list drop policies&gt;
    pass = &lt;set to yes to list bypass policies&gt;
    trap = &lt;set to yes to list trap policies&gt;
    child = &lt;filter by CHILD_SA configuration name&gt;
} =&gt; {
    # completes after streaming list-sa events
}
</pre><h3>list-conns()</h3>
<p>List currently loaded connections by streaming <em>list-conn</em> events. This call includes all connections known by the daemon, not only those loaded over vici. </p>
<pre class="fragment">{
    ike = &lt;list connections matching a given configuration name only&gt;
} =&gt; {
    # completes after streaming list-conn events
}
</pre><h3>get-conns()</h3>
<p>Return a list of connection names loaded exclusively over vici, not including connections found in other backends. </p>
<pre class="fragment">{} =&gt; {
    conns = [
        &lt;list of connection names&gt;
    ]
}
</pre><h3>list-certs()</h3>
<p>List currently loaded certificates by streaming <em>list-cert</em> events. This call includes all certificates known by the daemon, not only those loaded over vici. </p>
<pre class="fragment">{
    type = &lt;certificate type to filter for, or ANY&gt;
    subject = &lt;set to list only certificates having subject&gt;
} =&gt; {
    # completes after streaming list-cert events
}
</pre><h3>list-authorities()</h3>
<p>List currently loaded certification authority information by streaming <em>list-authority</em> events. </p>
<pre class="fragment">{
    name = &lt;list certification authority of a given name&gt;
} =&gt; {
    # completes after streaming list-authority events
}
</pre><h3>get-authorities()</h3>
<p>Return a list of currently loaded certification authority names. </p>
<pre class="fragment">{} =&gt; {
    authorities = [
        &lt;list of certification authority names&gt;
    ]
}
</pre><h3>load-conn()</h3>
<p>Load a single connection definition into the daemon. An existing connection with the same name gets updated or replaced. </p>
<pre class="fragment">{
    &lt;IKE_SA config name&gt; = {
        # IKE configuration parameters with authentication and CHILD_SA
        # subsections. Refer to swanctl.conf(5) for details.
    } =&gt; {
        success = &lt;yes or no&gt;
        errmsg = &lt;error string on failure&gt;
    }
}
</pre><h3>unload-conn()</h3>
<p>Unload a previously loaded connection definition by name. </p>
<pre class="fragment">{
    name = &lt;IKE_SA config name&gt;
} =&gt; {
    success = &lt;yes or no&gt;
    errmsg = &lt;error string on failure&gt;
}
</pre><h3>load-cert()</h3>
<p>Load a certificate into the daemon. </p>
<pre class="fragment">{
    type = &lt;certificate type, X509|X509CA|X509AA|X509CRL|X509AC&gt;
    data = &lt;PEM or DER encoded certificate data&gt;
} =&gt; {
    success = &lt;yes or no&gt;
    errmsg = &lt;error string on failure&gt;
}
</pre><h3>load-key()</h3>
<p>Load a private key into the daemon. </p>
<pre class="fragment">{
    type = &lt;private key type, RSA|ECDSA&gt;
    data = &lt;PEM or DER encoded key data&gt;
} =&gt; {
    success = &lt;yes or no&gt;
    errmsg = &lt;error string on failure&gt;
}
</pre><h3>load-shared()</h3>
<p>Load a shared IKE PSK, EAP or XAuth secret into the daemon. </p>
<pre class="fragment">{
    type = &lt;private key type, IKE|EAP|XAUTH&gt;
    data = &lt;raw shared key data&gt;
    owners = [
        &lt;list of shared key owner identities&gt;
    ]
} =&gt; {
    success = &lt;yes or no&gt;
    errmsg = &lt;error string on failure&gt;
}
</pre><h3>clear-creds()</h3>
<p>Clear all loaded certificate, private key and shared key credentials. This affects only credentials loaded over vici, but additionally flushes the credential cache. </p>
<pre class="fragment">{} =&gt; {
    success = &lt;yes or no&gt;
    errmsg = &lt;error string on failure&gt;
}
</pre><h3>load-authority()</h3>
<p>Load a single certification authority definition into the daemon. An existing authority with the same name gets replaced. </p>
<pre class="fragment">{
    &lt;certification authority name&gt; = {
        # certification authority parameters
        # refer to swanctl.conf(5) for details.
    } =&gt; {
        success = &lt;yes or no&gt;
        errmsg = &lt;error string on failure&gt;
    }
}
</pre><h3>unload-authority()</h3>
<p>Unload a previously loaded certification authority definition by name. </p>
<pre class="fragment">{
    name = &lt;certification authority name&gt;
} =&gt; {
    success = &lt;yes or no&gt;
    errmsg = &lt;error string on failure&gt;
}
</pre><h3>load-pool()</h3>
<p>Load an in-memory virtual IP and configuration attribute pool. Existing pools with the same name get updated, if possible. </p>
<pre class="fragment">{
    &lt;pool name&gt; = {
        addrs = &lt;subnet of virtual IP pool addresses&gt;
        &lt;attribute type&gt;* = [
            # attribute type is one of address, dns, nbns, dhcp, netmask,
            # server, subnet, split_include, split_exclude or a numerical
            # attribute type identifier.
            &lt;list of attributes for type&gt;
        ]
    }
} =&gt; {
    success = &lt;yes or no&gt;
    errmsg = &lt;error string on failure&gt;
}
</pre><h3>unload-pool()</h3>
<p>Unload a previously loaded virtual IP and configuration attribute pool. Unloading fails for pools with leases currently online. </p>
<pre class="fragment">{
    name = &lt;virtual IP address pool to delete&gt;
} =&gt; {
    success = &lt;yes or no&gt;
    errmsg = &lt;error string on failure&gt;
}
</pre><h3>get-pools()</h3>
<p>List the currently loaded pools. </p>
<pre class="fragment">{
    leases = &lt;set to yes to include leases&gt;
} =&gt; {
    &lt;pool name&gt;* = {
        base = &lt;virtual IP pool base address&gt;
        size = &lt;total number of addresses in the pool&gt;
        online = &lt;number of leases online&gt;
        offline = &lt;number of leases offline&gt;
        leases = {
            &lt;zero-based index&gt;* = {
                address = &lt;IP address&gt;
                identity = &lt;assigned identity&gt;
                status = &lt;online|offline&gt;
            }
        }
    }
}
</pre><h2>Server-issued events</h2>
<p>Based on the packet layer, the vici plugin raises event messages using named EVENT packets wrapping messages. The message contains event details.</p>
<h3>log</h3>
<p>The <em>log</em> event is issued to registered clients for each debug log message. This event is not associated with a command. </p>
<pre class="fragment">{
    group = &lt;subsystem identifier for debug message&gt;
    level = &lt;log level, 0-4&gt;
    thread = &lt;numerical thread identifier issuing the log message&gt;
    ikesa-name = &lt;name of IKE_SA, if log is associated with any&gt;
    ikesa-uniqued = &lt;unique identifier of IKE_A, if log associated with any&gt;
    msg = &lt;log message text&gt;
}
</pre><h3>control-log</h3>
<p>The <em>control-log</em> event is issued for log events during active <em>initiate</em> or <em>terminate</em> commands. It is issued only to clients currently having such a command active. </p>
<pre class="fragment">{
    group = &lt;subsystem identifier for debug message&gt;
    level = &lt;log level, 0-4&gt;
    ikesa-name = &lt;name of IKE_SA, if log associated with any&gt;
    ikesa-uniqued = &lt;unique identifier of IKE_A, if log associated with any&gt;
    msg = &lt;log message text&gt;
}
</pre><h3>list-sa</h3>
<p>The <em>list-sa</em> event is issued to stream IKE_SAs during an active <em>list-sas</em> command. </p>
<pre class="fragment">{
    &lt;IKE_SA config name&gt; = {
        uniqueid = &lt;IKE_SA unique identifier&gt;
        version = &lt;IKE version, 1 or 2&gt;
        state = &lt;IKE_SA state name&gt;
        local-host = &lt;local IKE endpoint address&gt;
        local-id = &lt;local IKE identity&gt;
        remote-host = &lt;remote IKE endpoint address&gt;
        remote-id = &lt;remote IKE identity&gt;
        remote-xauth-id = &lt;remote XAuth identity, if XAuth-authenticated&gt;
        remote-eap-id = &lt;remote EAP identity, if EAP-authenticated&gt;
        initiator = &lt;yes, if initiator of IKE_SA&gt;
        initiator-spi = &lt;hex encoded initiator SPI / cookie&gt;
        responder-spi = &lt;hex encoded responder SPI / cookie&gt;
        nat-local = &lt;yes, if local endpoint is behind a NAT&gt;
        nat-remote = &lt;yes, if remote endpoint is behind a NAT&gt;
        nat-fake = &lt;yes, if NAT situation has been faked as responder&gt;
        nat-any = &lt;yes, if any endpoint is behind a NAT (also if faked)&gt;
        encr-alg = &lt;IKE encryption algorithm string&gt;
        encr-keysize = &lt;key size for encr-alg, if applicable&gt;
        integ-alg = &lt;IKE integrity algorithm string&gt;
        integ-keysize = &lt;key size for encr-alg, if applicable&gt;
        prf-alg = &lt;IKE pseudo random function string&gt;
        dh-group = &lt;IKE Diffie-Hellman group string&gt;
        established = &lt;seconds the IKE_SA has been established&gt;
        rekey-time = &lt;seconds before IKE_SA gets rekeyed&gt;
        reauth-time = &lt;seconds before IKE_SA gets re-authenticated&gt;
        local-vips = [
            &lt;list of virtual IPs assigned by the remote peer, installed locally&gt;
        ]
        remote-vips = [
            &lt;list of virtual IPs assigned to the remote peer&gt;
        ]
        tasks-queued = [
            &lt;list of currently queued tasks for execution&gt;
        ]
        tasks-active = [
            &lt;list of tasks currently initiating actively&gt;
        ]
        tasks-passive = [
            &lt;list of tasks currently handling passively&gt;
        ]
        child-sas = {
            &lt;child-sa-name&gt;* = {
                uniqueid = &lt;unique CHILD_SA identifier&gt;
                reqid = &lt;reqid of CHILD_SA&gt;
                state = &lt;state string of CHILD_SA&gt;
                mode = &lt;IPsec mode, tunnel|transport|beet&gt;
                protocol = &lt;IPsec protocol AH|ESP&gt;
                encap = &lt;yes if using UDP encapsulation&gt;
                spi-in = &lt;hex encoded inbound SPI&gt;
                spi-out = &lt;hex encoded outbound SPI&gt;
                cpi-in = &lt;hex encoded inbound CPI, if using compression&gt;
                cpi-out = &lt;hex encoded outbound CPI, if using compression&gt;
                encr-alg = &lt;ESP encryption algorithm name, if any&gt;
                encr-keysize = &lt;ESP encryption key size, if applicable&gt;
                integ-alg = &lt;ESP or AH integrity algorithm name, if any&gt;
                integ-keysize = &lt;ESP or AH integrity key size, if applicable&gt;
                prf-alg = &lt;CHILD_SA pseudo random function name&gt;
                dh-group = &lt;CHILD_SA PFS rekeying DH group name, if any&gt;
                esn = &lt;1 if using extended sequence numbers&gt;
                bytes-in = &lt;number of input bytes processed&gt;
                packets-in = &lt;number of input packets processed&gt;
                use-in = &lt;seconds since last inbound packet, if any&gt;
                bytes-out = &lt;number of output bytes processed&gt;
                packets-out = &lt;number of output packets processed&gt;
                use-out = &lt;seconds since last outbound packet, if any&gt;
                rekey-time = &lt;seconds before CHILD_SA gets rekeyed&gt;
                life-time = &lt;seconds before CHILD_SA expires&gt;
                install-time = &lt;seconds the CHILD_SA has been installed&gt;
                local-ts = [
                    &lt;list of local traffic selectors&gt;
                ]
                remote-ts = [
                    &lt;list of remote traffic selectors&gt;
                ]
            }
        }
    }
}
</pre><h3>list-policy</h3>
<p>The <em>list-policy</em> event is issued to stream installed policies during an active <em>list-policies</em> command. </p>
<pre class="fragment">{
    &lt;child-sa-config-name&gt; = {
        mode = &lt;policy mode, tunnel|transport|pass|drop&gt;
        local-ts = [
            &lt;list of local traffic selectors&gt;
        ]
        remote-ts = [
            &lt;list of remote traffic selectors&gt;
        ]
    }
}
</pre><h3>list-conn</h3>
<p>The <em>list-conn</em> event is issued to stream loaded connection during an active <em>list-conns</em> command. </p>
<pre class="fragment">{
    &lt;IKE_SA connection name&gt; = {
        local_addrs = [
            &lt;list of valid local IKE endpoint addresses&gt;
        ]
        remote_addrs = [
            &lt;list of valid remote IKE endpoint addresses&gt;
        ]
        version = &lt;IKE version as string, IKEv1|IKEv2 or 0 for any&gt;

        local*, remote* = { # multiple local and remote auth sections
            class = &lt;authentication type&gt;
            eap-type = &lt;EAP type to authenticate if when using EAP&gt;
            eap-vendor = &lt;EAP vendor for type, if any&gt;
            xauth = &lt;xauth backend name&gt;
            revocation = &lt;revocation policy&gt;
            id = &lt;IKE identity&gt;
            aaa_id = &lt;AAA authentication backend identity&gt;
            eap_id = &lt;EAP identity for authentication&gt;
            xauth_id = &lt;XAuth username for authentication&gt;
            groups = [
                &lt;group membership required to use connection&gt;
            ]
            certs = [
                &lt;certificates allowed for authentication&gt;
            ]
            cacerts = [
                &lt;CA certificates allowed for authentication&gt;
            ]
        }
        children = {
            &lt;CHILD_SA config name&gt;* = {
                mode = &lt;IPsec mode&gt;
                local-ts = [
                    &lt;list of local traffic selectors&gt;
                ]
                remote-ts = [
                    &lt;list of remote traffic selectors&gt;
                ]
            }
        }
    }
}
</pre><h3>list-cert</h3>
<p>The <em>list-cert</em> event is issued to stream loaded certificates during an active <em>list-certs</em> command. </p>
<pre class="fragment">{
    type = &lt;certificate type&gt;
    has_privkey = &lt;set if a private key for the certificate is available&gt;
    data = &lt;ASN1 encoded certificate data&gt;
}
</pre><h3>list-authority</h3>
<p>The <em>list-authority</em> event is issued to stream loaded certification authority information during an active_list-authorities_ command. </p>
<pre class="fragment">{
    &lt;certification authority name&gt; = {
        cacert = &lt;subject distinguished name of CA certificate&gt;
        crl_uris = [
            &lt;CRL URI (http, ldap or file)&gt;
        ]
        ocsp_uris = [
            &lt;OCSP URI (http)&gt;
        ]
        cert_uri_base = &lt;base URI for download of hash-and-URL certificates&gt;
    }
}
</pre><h3>ike-updown</h3>
<p>The <em>ike-updown</em> event is issued when an IKE_SA is established or terminated. </p>
<pre class="fragment">{
    up = &lt;yes or no&gt;
    &lt;IKE_SA config name&gt; = {
        &lt;same data as in the list-sas event, but without child-sas section&gt;
    }
}
</pre><h3>ike-rekey</h3>
<p>The <em>ike-rekey</em> event is issued when an IKE_SA is rekeyed. </p>
<pre class="fragment">{
    &lt;IKE_SA config name&gt; = {
        old = {
            &lt;same data as in the list-sas event, but without child-sas section&gt;
        }
        new = {
            &lt;same data as in the list-sas event, but without child-sas section&gt;
        }
    }
}
</pre><h3>child-updown</h3>
<p>The <em>child-updown</em> event is issued when a CHILD_SA is established or terminated. </p>
<pre class="fragment">{
    up = &lt;yes or no&gt;
    &lt;IKE_SA config name&gt; = {
        &lt;same data as in the list-sas event, but with only the affected
         CHILD_SA in the child-sas section&gt;
    }
}
</pre><h3>child-rekey</h3>
<p>The <em>child-rekey</em> event is issued when a CHILD_SA is rekeyed. </p>
<pre class="fragment">{
    &lt;IKE_SA config name&gt; = {
        &lt;same data as in the list-sas event, but with the child-sas section
         as follows&gt;
        child-sas = {
            &lt;child-sa-name&gt; = {
                old = {
                    &lt;same data as in the list-sas event&gt;
                }
                new = {
                    &lt;same data as in the list-sas event&gt;
                }
            }
        }
    }
}
</pre><h1>libvici C client library</h1>
<p>libvici is the reference implementation of a C client library implementing the vici protocol. It builds upon libstrongswan, but provides a stable API to implement client applications in the C programming language. libvici uses the libstrongswan thread pool to deliver event messages asynchronously.</p>
<h2>Connecting to the daemon</h2>
<p>This example shows how to connect to the daemon using the default URI, and then perform proper cleanup: </p>
<pre class="fragment">#include &lt;stdio.h&gt;
#include &lt;errno.h&gt;
#include &lt;string.h&gt;

#include &lt;libvici.h&gt;

int main(int argc, char *argv[])
{
    vici_conn_t *conn;
    int ret = 0;

    vici_init();
    conn = vici_connect(NULL);
    if (conn)
    {
        /* do stuff 
        vici_disconnect(conn);
    }
    else
    {
        ret = errno;
        fprintf(stderr, "connecting failed: %s\n", strerror(errno));
    }
    vici_deinit();
    return ret;
}
</pre><h2>A simple client request</h2>
<p>In the following example, a simple <em>version</em> request is issued to the daemon and the result is printed: </p>
<pre class="fragment">int get_version(vici_conn_t *conn)
{
    vici_req_t *req;
    vici_res_t *res;
    int ret = 0;

    req = vici_begin("version");
    res = vici_submit(req, conn);
    if (res)
    {
        printf("%s %s (%s, %s, %s)\n",
            vici_find_str(res, "", "daemon"),
            vici_find_str(res, "", "version"),
            vici_find_str(res, "", "sysname"),
            vici_find_str(res, "", "release"),
            vici_find_str(res, "", "machine"));
        vici_free_res(res);
    }
    else
    {
        ret = errno;
        fprintf(stderr, "version request failed: %s\n", strerror(errno));
    }
    return ret;
}
</pre><h2>A request with event streaming and callback parsing</h2>
<p>In this more advanced example, the <em>list-conns</em> command is used to stream loaded connections with the <em>list-conn</em> event. The event message is parsed with a simple callback to print the connection name: </p>
<pre class="fragment">int conn_cb(void *null, vici_res_t *res, char *name)
{
    printf("%s\n", name);
    return 0;
}

void list_cb(void *null, char *name, vici_res_t *res)
{
    if (vici_parse_cb(res, conn_cb, NULL, NULL, NULL) != 0)
    {
        fprintf(stderr, "parsing failed: %s\n", strerror(errno));
    }
}

int list_conns(vici_conn_t *conn)
{
    vici_req_t *req;
    vici_res_t *res;
    int ret = 0;

    if (vici_register(conn, "list-conn", list_cb, NULL) == 0)
    {
        req = vici_begin("list-conns");
        res = vici_submit(req, conn);
        if (res)
        {
            vici_free_res(res);
        }
        else
        {
            ret = errno;
            fprintf(stderr, "request failed: %s\n", strerror(errno));
        }
        vici_register(conn, "list-conn", NULL, NULL);
    }
    else
    {
        ret = errno;
        fprintf(stderr, "registration failed: %s\n", strerror(errno));
    }
    return ret;
}
</pre><h2>API documentation</h2>
<p>More information about the libvici API is available in the <em><a class="el" href="../../db/d8b/libvici_8h.html">libvici.h</a></em> header file or the generated Doxygen documentation.</p>
<h1>vici ruby gem</h1>
<p>The <em>vici ruby gem</em> is a pure ruby implementation of the VICI protocol to implement client applications. It is provided in the <em>ruby</em> subdirectory, and gets built and installed if strongSwan has been _./configure_'d with _&ndash;enable-vici_ and _&ndash;enable-ruby-gems_.</p>
<p>The <em>Connection</em> class from the <em>Vici</em> module provides the high level interface, the underlying classes are usually not required to build ruby applications using VICI. The <em>Connection</em> class provides methods for the supported VICI commands and an event listening mechanism.</p>
<p>To represent the VICI message data tree, the gem converts the binary encoding to ruby data types. The <em>Connection</em> class takes and returns ruby objects for the exchanged message data:</p>
<ul>
<li>Sections get encoded as Hash, containing other sections as Hash, or</li>
<li>Key/Values, where the values are Strings as Hash values</li>
<li>Lists get encoded as Arrays with String values Non-String values that are not a Hash nor an Array get converted with .to_s during encoding.</li>
</ul>
<h2>Connecting to the daemon</h2>
<p>To create a connection to the daemon, a socket can be passed to the <em>Connection</em> constructor. If none is passed, a default Unix socket at _/var/run/charon.vici_ is used: </p>
<pre class="fragment">require "vici"
require "socket"

v = Vici::Connection.new(UNIXSocket.new("/var/run/charon.vici"))
</pre><h2>A simple client request</h2>
<p>An example to print the daemon version information is as simple as: </p>
<pre class="fragment">x = v.version
puts "%s %s (%s, %s, %s)" % [
    x["daemon"], x["version"], x["sysname"], x["release"], x["machine"]
]
</pre><h2>A request with closure invocation</h2>
<p>The <em>Connection</em> class takes care of event streaming by invoking a closure for each event. The following example lists all loaded connections using the <em>list-conns</em> command and implicitly the <em>list-conn</em> event: </p>
<pre class="fragment">v.list_conns { |conn|
    conn.each { |key, value|
        puts key
    }
}
</pre><h2>API documentation</h2>
<p>For more details about the ruby gem refer to the comments in the gem source code or the generated documentation.</p>
<h1>vici Python egg</h1>
<p>The <em>vici Python egg</em> is a pure Python implementation of the VICI protocol to implement client applications. It is provided in the <em>python</em> subdirectory, and gets built and installed if strongSwan has been _./configure_'d with _&ndash;enable-vici_ and _&ndash;enable-python-eggs_.</p>
<p>The <em>vici</em> module provides a <em>Session()</em> constructor for a high level interface, the underlying classes are usually not required to build Python applications using VICI. The <em>Session</em> class provides methods for the supported VICI commands.</p>
<p>To represent the VICI message data tree, the library converts the binary encoding to Python data types. The <em>Session</em> class takes and returns Python objects for the exchanged message data:</p>
<ul>
<li>Sections get encoded as OrderedDict, containing other sections, or</li>
<li>Key/Values, where the values are strings as dictionary values</li>
<li>Lists get encoded as Python Lists with string values Values that do not conform to Python dict or list get converted to strings using <a class="el" href="../../d9/d7b/settings__lexer_8c.html#a94688a4a25a03cfbc6929fe15b1f8df0">str()</a>.</li>
</ul>
<h2>Connecting to the daemon</h2>
<p>To create a connection to the daemon, a socket can be passed to the <em>Session</em> constructor. If none is passed, a default Unix socket at _/var/run/charon.vici_ is used: </p>
<pre class="fragment">import vici
import socket

s = socket.socket(socket.AF_UNIX)
s.connect("/var/run/charon.vici")
v = vici.Session(s)
</pre><h2>A simple client request</h2>
<p>An example to print the daemon version information is as simple as: </p>
<pre class="fragment">ver = v.version()

print "{daemon} {version} ({sysname}, {release}, {machine})".format(**ver)
</pre><h2>A request with response iteration</h2>
<p>The <em>Session</em> class returns an iterable Python generator for streamed events to continuously stream objects to the caller. The following example lists all loaded connections using the <em>list-conns</em> command and implicitly the <em>list-conn</em> event: </p>
<pre class="fragment">for conn in v.list_conns():
    for key in conn:
        print key
</pre><p>Please note that if the returned generator is not iterated completely, it must be closed using <em><a class="el" href="../../da/d9b/group__windows.html#ga9c7f6d5331abb2692a876d5ee67474b7">close()</a></em>. This is implicitly done when breaking from a loop, but an explicit call may be required when directly iterating the generator with <em><a class="el" href="../../d4/d2b/leak__detective_8c.html#a8ad91963e97959c834d908f0ac9cca66">next()</a></em>.</p>
<h2>Sorting in dictionaries</h2>
<p>In VICI, in some message trees the order of objects in dictionary matters. In contrast to ruby Hashes, Python dictionaries do not preserve order of added objects. It is therefore recommended to use OrderedDicts instead of the default dictionaries. Objects returned by the library use OrderedDicts.</p>
<h2>API documentation</h2>
<p>For more details about the Python egg refer to the comments in the Python source code. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Wed Jan 20 2016 14:04:14 for strongSwan by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="../../doxygen.png" alt="doxygen"/></a> 1.8.6 </li>
  </ul>
</div>
</body>
</html>
